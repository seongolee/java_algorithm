package algorithm;

/*
* 그리디 알고리즘 - 현재 상황에서 당장 좋은 것만 고르는 방법
* */

public class greedy {
    public static void main(String[] args) {
        case1();
    }

    /*
    * 거스름돈
    * 손님에게 거슬러줘야할 돈이 N원일 때 동전의 최소 개수를 구하라
    * 동전의 종류는 500, 100, 50, 10원이 존재함
    * N은 10의 배수이다.
    * */

    /*
    * 알고리즘의 포인트
    * 제일 큰 수의 값부터 거슬러주는 것
    * */
    static void case1() {
        int testCase[] = {600, 1890};
        int coins[] = {500, 100, 50, 10}; // 동전의 종류
        int answer = 0; // 동전의 개수

        for(int i=0; i<testCase.length; i++) {
            for(int coin: coins) {
                answer += (testCase[i]/coin);
                testCase[i] %= coin;
            }

            System.out.println("동전의 개수: " + answer);
        }
    }

    /* 큰 수의 법칙
    * 다양한 수로 이루어진 배열이 있을때 주어진 수들을 M번 더하여 가장 큰 수를 만드는 법칙
    * 단, 배열의 특정한 인덱스(번호)에 해당하는 수가 연속해서 K번을 초과하여 더해질 수 없는 것이 이 법칙의 특징이다.
    * 배열의 크기 N, 숫자가 더해지는 횟수 M, 그리고 K가 주어질 때 큰 수의 법칙에 따른 결과를 출력하시오.
    *
    * 입력조건
    * 첫째 줄에 N(2 <= N <= 1000), M(1 <= M <= 10000), K(1 <= K <= 10000)의 자연수가 주어지며, 각 자연수는 공백으로 구분한다.
    * 둘째 줄에 N개의 자연수가 주어진다. 각 자연수는 공백으로 구분한다. 단, 각각의 자연수는 1 이상 10000이하의 수로 주어진다.
    * 입력으로 주어지는 K는 항상 M보다 작거나 같다.
    * */

    /*
    * 알고리즘 포인트*/
    static void case2() {

    }
}
